# 网页渲染
## 文章出处
http://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&mid=200299294&idx=1&sn=7884218cbfb908c9c7050925ff443c78#rd
## 浏览器是怎样渲染一个界面的
1. 由从服务器接收到的 HTML 形成 DOM（文档对象模型）。
2. 样式被加载和解析，形成 CSSOM（CSS 对象模型）。
3. 紧接着 DOM 和 CSSOM 创建了一个渲染树，这个渲染树是一些被渲染对象的集合（ Webkit 分别叫它们”renderer”和”render object”，而在Gecko 引擎中叫”frame”）。除了不可见的元素（比如 head 标签和一些有 display:none 属性的元素），渲染树映射了 DOM 的结构。在渲染树中，每一个文本字符串都被当做一个独立的 renderer。每个渲染对象都包含了与之对应的计算过样式的DOM 对象（或者一个文本块）。换句话说，渲染树描述了 DOM 的直观的表现形式。
4. 对每个渲染元素来说，它的坐标是经过计算的，这被叫做“布局(layout)”。浏览器使用一种只需要一次处理的“流方法”来布局所有元素（tables需要多次处理）。
5. 最后，将布局显示在浏览器窗口中，这个过程叫做“绘制(painting)”。
## 重绘和重排
1. 当在页面上修改了一些不需要改变定位的样式的时候（比如background-color,border-color,visibility)，
浏览器只会将新的样式重新绘制给元素（这就叫一次“重绘”或者“重新定义样式”）。
2. 当页面上的改变影响了文档内容、结构或者元素定位时，就会发生重排（或称“重新布局”）。
## 重排的触发
1. DOM 操作（如元素增、删、改或者改变元素顺序）。
2. 内容的改变，包括 Form 表单中文字的变化。
3. 计算或改变 CSS 属性。
4. 增加或删除一个样式表。
5. 改变”class”属性。
6. 浏览器窗口的操作（改变大小、滚动窗口）。
7. 激活伪类（如:hover状态）。
## 浏览器对渲染的优化
1. 浏览器尽最大努力限制重排的过程仅覆盖已更改的元素的区域。

    举个例子，一个 position 为 absolue 或 fixed 的元素的大小变化只影响它自身和子孙元素，
而对一个 position 为 static 的元素做同样的操作就会引起所有它后面元素的重排。

2. 当运行一段javascript 代码的时候，浏览器会将一些修改缓存起来，然后当代码执行的时候，一次性的将这些修改执行。

    如
    
        var $body = $('body');
        $body.css('padding', '1px'); // 重排, 重绘
        $body.css('color', 'red'); // 重绘
        $body.css('margin', '2px'); // 重排, 重绘
        // 实际上只有一次重排和重绘被执行
        
     访问一个元素的属性会进行一次强制重排，因此，为了提高性能，你应该讲读取元素属性的代码组织在一起，当需要强制触发重排时，也可以通过读取元素属性实现。
  ## 优化建议
  1. 创建合法的 HTML 和 CSS ，别忘了制定文件编码，Style 应该写在 head 标签中，script 标签应该加载 body 标签结束的位置。
  2. 试着简化和优化 CSS 选择器（这个优化点被大多数使用 CSS 预处理器的开发者忽略了）。将嵌套层数控制在最小。以下是 CSS 选择器的性能排行（从最快的开始）：
      1. ID选择器：#id
      2. class选择器： .class
      3. 标签: div
      4. 相邻的兄弟元素：a + i
      5. 父元素选择器： ul > li
      6. 通配符选择器： *
      7. 伪类和伪元素： a:hover ，你应该记住浏览器处理选择器是从右向左的，这也就是为什么最右面的选择器会更快——#id或.class。
   3. 尽量减少dom操作
   4. 要改变元素的样式，修改“class”属性是最高效的方式之一。你要改变 DOM 树的层次越深，这一条就越高效（这也有助于将表现和逻辑分开）。
   5. 尽可能的只对 position 为 absolute 或 fix 的元素做动画。
   6. 当滚动时禁用一些复杂的 :hover 动画是一个很好的主意（例如，给 body 标签加一个 no-hover 的 class）。
     
